<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="p:domain_verify" content="897b2ab99a4574dcf13a397042fb9827"/>
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Mappedbus: A library for low latency IPC between multiple Java processes/JVMs</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Mappedbus</h1>
        <h2>A library for low latency IPC between multiple Java processes/JVMs</h2>
        <a href="https://github.com/caplogic/Mappedbus" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h2>
<a id="mappedbus-is-a-java-based-high-throughput-low-latency-message-bus-using-either-a-memory-mapped-file-or-shared-memory-as-transport" class="anchor" href="#mappedbus-is-a-java-based-high-throughput-low-latency-message-bus-using-either-a-memory-mapped-file-or-shared-memory-as-transport" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mappedbus is a Java based high throughput, low latency message bus, using either a memory mapped file or shared memory as transport</h2>

<p>Mappedbus was inspired by <a href="https://github.com/OpenHFT/Chronicle-Queue">Java Chronicle</a> with the main difference that it's designed to efficiently support multiple writers â€“ enabling use cases where the order of messages produced by multiple processes are important.</p>

<p>The throughput (on a laptop, i7-4558U @ 2.8 GHz) between a single producer writing at full speed and a single consumer is around 40 million messages per second (a small message consisting of three integer fields), and the average read/write latency is around 25 ns per message.</p>

<p>Mappedbus does not create any objects after startup and therefore has no GC impact.</p>

<h4>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features:</h4>

<ul>
<li>IPC between multiple processes by message passing</li>
<li>Support for either a memory mapped file or shared memory as transport</li>
<li>Support for either object or byte array (raw data) based messages</li>
</ul>

<h3>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting Started</h3>

<p>Download the zip file which contains mappedbus.jar in the dist folder (or clone the project and build it from source by running "ant") and try out any of the sample applications described below.</p>

<h3>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h3>

<p>Setup a reader and a writer:</p>

<div class="highlight highlight-java"><pre><span class="pl-c">// Setup a reader</span>
<span class="pl-smi">MappedBusReader</span> reader <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MappedBusReader</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/test<span class="pl-pds">"</span></span>, <span class="pl-c1">100000L</span>, <span class="pl-c1">32</span>);
reader<span class="pl-k">.</span>open();

<span class="pl-c">// Setup a writer</span>
<span class="pl-smi">MappedBusWriter</span> writer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">MappedBusWriter</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/test<span class="pl-pds">"</span></span>, <span class="pl-c1">100000L</span>, <span class="pl-c1">32</span>, <span class="pl-c1">true</span>);
writer<span class="pl-k">.</span>open();</pre></div>

<p>In the code above the file "/tmp/test" is on disk and thus it's memory mapped by the library. To instead use the library with shared memory, point to a file in "/dev/shm", for example, "/dev/shm/test".</p>

<p>When using a memory mapped file the messages will be lazily persisted to disk. With shared memory the messages will instead be stored in the RAM.
<br><br>
Read/write messages using objects:</p>

<div class="highlight highlight-java"><pre><span class="pl-smi">PriceUpdate</span> priceUpdate <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">PriceUpdate</span>();

<span class="pl-c">// write a message</span>
writer<span class="pl-k">.</span>write(priceUpdate);

<span class="pl-c">// read messages</span>
<span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
   <span class="pl-k">if</span> (reader<span class="pl-k">.</span>next()) {
      <span class="pl-k">int</span> type <span class="pl-k">=</span> reader<span class="pl-k">.</span>readType();
      <span class="pl-k">if</span> (type <span class="pl-k">==</span> <span class="pl-c1">0</span>) {
         reader<span class="pl-k">.</span>readMessage(priceUpdate)
      }
   }
}</pre></div>

<p>Read/write messages using byte arrays:</p>

<div class="highlight highlight-java"><pre><span class="pl-k">byte</span>[] buffer <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">byte</span>[<span class="pl-c1">32</span>];

<span class="pl-c">// write a buffer</span>
writer<span class="pl-k">.</span>write(buffer, <span class="pl-c1">0</span>, buffer<span class="pl-k">.</span>length);

<span class="pl-c">// read buffers</span>
<span class="pl-k">while</span> (<span class="pl-c1">true</span>) {
   <span class="pl-k">if</span> (reader<span class="pl-k">.</span>next()) {
      <span class="pl-k">int</span> length <span class="pl-k">=</span> reader<span class="pl-k">.</span>read(buffer, <span class="pl-c1">0</span>);
   }
}</pre></div>

<h3>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h3>

<p>The project contains examples of an object based and a byte array based reader/writer.</p>

<p>The object based one work as follows. The ObjectWriter class will send a message, PriceUpdate, which contains three fields: source, price and quantity. The first argument of the ObjectWriter is used to populate the source. The ObjectReader simply prints every message it receives.</p>

<pre><code>&gt; java -cp mappedbus.jar io.mappedbus.sample.object.ObjectWriter 0
...
</code></pre>

<pre><code>&gt; java -cp mappedbus.jar io.mappedbus.sample.object.ObjectWriter 1
...
</code></pre>

<pre><code>&gt; java -cp mappedbus.jar io.mappedbus.sample.object.ObjectReader
...
Read: PriceUpdate [source=0, price=20, quantity=40]
Read: PriceUpdate [source=1, price=8, quantity=16]
Read: PriceUpdate [source=0, price=22, quantity=44]
</code></pre>

<p>The byte array based example is run in the same way.</p>

<p>Another example simulates a token passed around between a number of nodes. Each node will send a message, Token, which contains two fields: to and from. When a node receives a token it will check whether it's the receiver and if so it will send a new token message with the "to" field set to it's id + 1 mod "number of nodes".</p>

<pre><code>&gt; java -cp mappedbus.jar io.mappedbus.sample.token.Token 0 3
Read: Token [from=0, to=1]
Read: Token [from=1, to=2]
...
</code></pre>

<pre><code>&gt; java -cp mappedbus.jar io.mappedbus.sample.token.Token 1 3
Read: Token [from=0, to=1]
Read: Token [from=1, to=2]
...
</code></pre>

<pre><code>&gt; java -cp mappedbus.jar io.mappedbus.sample.token.Token 2 3
Read: Token [from=0, to=1]
Read: Token [from=1, to=2]
...
</code></pre>

<h3>
<a id="performance" class="anchor" href="#performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance</h3>

<p>The project contains a performance test which can be run as follows:</p>

<pre><code>&gt; java -cp mappedbus.jar io.mappedbus.perf.MessageWriter /tmp/test
...
</code></pre>

<pre><code>&gt; java -cp mappedbus.jar io.mappedbus.perf.MessageReader /tmp/test
Elapsed: 1801 ms
Per op: 22 ns
Op/s: 44404868
</code></pre>

<h3>
<a id="implementation" class="anchor" href="#implementation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation</h3>

<p>Here's how Mappedbus solves the synchronization problem between multiple writers (each running in it's own process/JVM):</p>

<ul>
<li><p>The first eight bytes of the file make up a field called the limit. This field specifies how much data has actually been written to the file. The readers will poll the limit field (using volatile) to see whether there's a new record to be read.</p></li>
<li><p>When a writer wants to add a record to the file it will use the fetch-and-add instruction to atomically update the limit field.</p></li>
<li><p>When the limit field has increased a reader will know there's new data to be read, but the writer which updated the limit field might not yet have written any data in the record. To avoid this problem each record contains an initial byte which make up the commit field.</p></li>
<li><p>When a writer has finished writing a record it will set the commit field (using volatile) and the reader will only start reading a record once it has seen that the commit field has been set.</p></li>
<li><p>A writer might crash after it has updated the limit field but before it has updated the commit field. To avoid this problem there's a field next to the commit field called the rollback field. The reader has a timeout for how long it will wait for the commit field to be set. When that time is reached the reader will set the rollback field (using volatile) and continue with the next record. The rollback field has precedence over the commit field, when the rollback field is set the record is always ignored by the readers.</p></li>
</ul>

<p>The solution seems to work well on Linux x86 with Oracle's JVM (1.8) but it probably won't work on all platforms. The project contains a test (called IntegrityTest) to check whether it works on the platform used.</p>

<h3>
<a id="questions" class="anchor" href="#questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Questions</h3>

<p>For questions or suggestions feel free to drop a mail to <a href="mailto:info@mappedbus.io">info@mappedbus.io</a></p>
        </section>

        <aside id="sidebar">
          <a href="http://mappedbus.io/doc" class="button">
            <small>View</small>
            Javadoc
          </a>
          <a href="https://github.com/caplogic/MappedBus/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/caplogic/MappedBus/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/caplogic/MappedBus"></a>The project is maintained by <a href="https://github.com/caplogic">caplogic</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-63315071-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
